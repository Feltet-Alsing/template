import { writeFile, readdir, mkdir, unlink } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { z, ZodObject } from 'zod';
import { spawn } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Import the entities config
import { entities } from '../src/lib/db/entities.config.js';

// Helper to convert entity name to PascalCase
function toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper to pluralize entity name for "getAll" function
function toPlural(str: string): string {
    if (str.endsWith('s')) return str;
    return str + 's';
}

// Map Zod types to PostgreSQL types
function zodToPostgresType(zodType: any): string {
    if (zodType instanceof z.ZodString) {
        return 'TEXT';
    } else if (zodType instanceof z.ZodNumber) {
        return 'DECIMAL(10, 2)';
    } else if (zodType instanceof z.ZodBoolean) {
        return 'BOOLEAN';
    } else if (zodType instanceof z.ZodDate) {
        return 'TIMESTAMP';
    } else if (zodType instanceof z.ZodOptional) {
        return zodToPostgresType(zodType._def.innerType);
    } else {
        return 'TEXT'; // Default fallback
    }
}

// Check if a Zod type is optional
function isOptional(zodType: any): boolean {
    return zodType instanceof z.ZodOptional;
}

async function generateEntitiesRemote() {
    const entityNames = Object.keys(entities) as Array<keyof typeof entities>;

    let imports = `/**
 * Auto-generated CRUD Operations from Entity Config
 * 
 * This file is AUTO-GENERATED by 'yarn generate-entities'
 * DO NOT EDIT MANUALLY - changes will be overwritten!
 * 
 * To add/modify entities, edit src/lib/db/entities.config.ts
 * then run 'yarn generate-entities'
 */

import { createCrud } from './crud-factory';
import { entities } from './entities.config';

`;

    let exports = '';

    for (const entityName of entityNames) {
        const pascalName = toPascalCase(entityName);
        const pluralName = toPlural(pascalName);

        exports += `// Generate CRUD operations for ${entityName}\n`;
        exports += `const ${entityName}Crud = createCrud(entities.${entityName});\n\n`;
        exports += `export const getAll${pluralName} = ${entityName}Crud.getAll;\n`;
        exports += `export const get${pascalName} = ${entityName}Crud.getById;\n`;
        exports += `export const create${pascalName} = ${entityName}Crud.create;\n`;
        exports += `export const update${pascalName} = ${entityName}Crud.update;\n`;
        exports += `export const delete${pascalName} = ${entityName}Crud.delete;\n\n`;
    }

    const content = imports + exports;

    await writeFile(
        join(__dirname, '../src/lib/db/entities.remote.ts'),
        content,
        'utf-8'
    );

    console.log('âœ“ Generated src/lib/db/entities.remote.ts');
}

async function generateRegistry() {
    const entityNames = Object.keys(entities) as Array<keyof typeof entities>;

    let imports = `/**
 * Database Entity Registry
 * 
 * This file is AUTO-GENERATED by 'yarn generate-entities'
 * DO NOT EDIT MANUALLY - changes will be overwritten!
 * 
 * Usage:
 *   import { db } from '$lib/db/registry';
 *   const items = await db.entityName.getAll();
 *   await db.entityName.create({ ... });
 */

import {
`;

    let dbObject = `\nexport const db = {\n`;

    for (const entityName of entityNames) {
        const pascalName = toPascalCase(entityName);
        const pluralName = toPlural(pascalName);

        // Add to imports
        imports += `\tgetAll${pluralName},\n`;
        imports += `\tget${pascalName},\n`;
        imports += `\tcreate${pascalName},\n`;
        imports += `\tupdate${pascalName},\n`;
        imports += `\tdelete${pascalName},\n`;

        // Add to db object
        dbObject += `\t${entityName}: {\n`;
        dbObject += `\t\tgetAll: getAll${pluralName},\n`;
        dbObject += `\t\tgetById: get${pascalName},\n`;
        dbObject += `\t\tcreate: create${pascalName},\n`;
        dbObject += `\t\tupdate: update${pascalName},\n`;
        dbObject += `\t\tdelete: delete${pascalName}\n`;
        dbObject += `\t},\n`;
    }

    imports += `} from './entities.remote';\n`;
    dbObject += `};\n\n`;
    dbObject += `// Type-safe access to all entities\n`;
    dbObject += `export type DbEntity = keyof typeof db;\n`;

    const content = imports + dbObject;

    await writeFile(
        join(__dirname, '../src/lib/db/registry.ts'),
        content,
        'utf-8'
    );

    console.log('âœ“ Generated src/lib/db/registry.ts');
}

async function generateMigrate() {
    const migrationsDir = join(__dirname, '../src/lib/migrations');

    // Read all .sql files from migrations directory
    const files = await readdir(migrationsDir);
    const sqlFiles = files
        .filter(file => file.endsWith('.sql'))
        .sort(); // Sort to ensure consistent order

    let content = `import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import sql from './db.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Auto-generated Migration Runner
 * 
 * This file is AUTO-GENERATED by 'yarn generate-entities'
 * DO NOT EDIT MANUALLY - changes will be overwritten!
 * 
 * Migrations are automatically discovered from src/lib/migrations/*.sql
 * To add a migration, create a new .sql file and run 'yarn generate-entities'
 */

async function migrate() {
	try {
		console.log('Running migrations...\\n');
`;

    // Add each migration
    for (const file of sqlFiles) {
        const varName = 'migration_' + file.replace(/[.-]/g, '_');
        content += `
		// ${file}
		const ${varName} = await readFile(
			join(__dirname, 'migrations', '${file}'),
			'utf-8'
		);
		await sql.unsafe(${varName});
		console.log('âœ“ Migration ${file} completed');
`;
    }

    content += `
		await sql.end();
		console.log('\\nâœ“ All migrations completed');
	} catch (error) {
		console.error('Migration failed:', error);
		await sql.end();
		process.exit(1);
	}
}

migrate();
`;

    await writeFile(
        join(__dirname, '../src/lib/migrate.ts'),
        content,
        'utf-8'
    );

    console.log('âœ“ Generated src/lib/migrate.ts');
    console.log(`  Found ${sqlFiles.length} migration(s):`);
    sqlFiles.forEach(file => console.log(`    - ${file}`));
}

async function generateMigrations() {
    const migrationsDir = join(__dirname, '../src/lib/migrations');

    // Ensure migrations directory exists
    try {
        await mkdir(migrationsDir, { recursive: true });
    } catch (err) {
        // Directory might already exist
    }

    // Clean slate: Delete all existing migration files
    try {
        const existingFiles = await readdir(migrationsDir);
        const sqlFiles = existingFiles.filter(file => file.endsWith('.sql'));

        for (const file of sqlFiles) {
            await unlink(join(migrationsDir, file));
        }

        if (sqlFiles.length > 0) {
            console.log(`âœ“ Cleaned ${sqlFiles.length} old migration file(s)`);
        }
    } catch (err) {
        // No files to clean
    }

    const entityNames = Object.keys(entities) as Array<keyof typeof entities>;
    let migrationIndex = 1;

    for (const entityName of entityNames) {
        const entity = entities[entityName];
        const paddedIndex = String(migrationIndex).padStart(3, '0');
        const filename = `${paddedIndex}.${entityName}.sql`;
        const filepath = join(migrationsDir, filename);

        // Generate CREATE TABLE statement
        let sql = `-- Auto-generated migration for ${entityName}\n`;
        sql += `-- Generated by 'yarn generate-entities'\n\n`;
        sql += `CREATE TABLE IF NOT EXISTS ${entity.table} (\n`;
        sql += `\tid SERIAL PRIMARY KEY,\n`;

        // Add each field
        const schema = entity.schema;
        for (const field of entity.fields) {
            const fieldDef = (schema.shape as any)[field];
            const sqlType = zodToPostgresType(fieldDef);
            const optional = isOptional(fieldDef);
            const nullable = optional ? '' : ' NOT NULL';

            sql += `\t${field} ${sqlType}${nullable},\n`;
        }

        sql += `\tcreated_at TIMESTAMP DEFAULT NOW()\n`;
        sql += `);\n`;

        await writeFile(filepath, sql, 'utf-8');
        console.log(`âœ“ Generated migration: ${filename}`);

        migrationIndex++;
    }
}

function runMigrate(): Promise<void> {
    return new Promise((resolve, reject) => {
        console.log('\nðŸš€ Running migrations...\n');

        const migrate = spawn('yarn', ['migrate'], {
            stdio: 'inherit',
            shell: true
        });

        migrate.on('close', (code) => {
            if (code === 0) {
                resolve();
            } else {
                reject(new Error(`Migration failed with code ${code}`));
            }
        });

        migrate.on('error', (err) => {
            reject(err);
        });
    });
}

async function generate() {
    try {
        console.log('Generating entity files from config...\n');

        await generateMigrations();
        await generateEntitiesRemote();
        await generateRegistry();
        await generateMigrate();

        console.log('\nâœ“ All files generated successfully!');
        console.log('\nEntities configured:');
        (Object.keys(entities) as Array<keyof typeof entities>).forEach((name) => {
            console.log(`  - ${name}`);
        });

        // Auto-run migrations
        await runMigrate();

        console.log('\nâœ… Generation and migration complete!');
    } catch (error) {
        console.error('Generation failed:', error);
        process.exit(1);
    }
}

generate();
